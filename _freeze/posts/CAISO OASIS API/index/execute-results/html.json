{
  "hash": "a554e1d5db88981d9609e66933c8d73a",
  "result": {
    "markdown": "---\ntitle: \"CAISO OASIS API\"\nauthor: \"Ryan McManus\"\ndate: \"2023-11-01\"\ncategories: [R, function, code]\nimage: \"cover.png\"\n---\n\n\nFor this post we'll walk through creating an API function for downloading CAISO OASIS data through their supported API. I will be referencing the [Interface Specification for OASIS](https://www.caiso.com/Documents/OASISAPISpecification.pdf \"API Doc\"). This document walks you through how to query the back-end system to extract a variety of data. Today we'll be looking to get access to their day-ahead, fifteen minute, and real-time markets.\n\nI will be using the single reports, as described in section 2.1. The basic format goes as followed:\n\n`URL?queryname=&startdate=&enddate=&market_run_id=&varParameters`\n\nUpdated info --https://www.caiso.com/Documents/OASIS-Frequently-Asked-Questions.pdf\n\nAssemble our variables...\n\nLet's setup the initial variables for the query.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(httr)\nlibrary(XML)\n\nstartdate<-'2023-01-15'\nenddate<-'2023-01-30'\nmarket_run_id<-'RTM'\napi_version<-2\nqueryname<-'PRC_INTVL_LMP'\nnodes<-c('TH_NP15_GEN-APND','TH_SP15_GEN-APND')\n```\n:::\n\n\nThis API requires a string of nodes be provided to the call. The function below will concatenate our vector string of nodes.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconcat_nodes<-function(x){if(length(x)>1){\n output=paste(x,collapse=\",\") \n}else{output=x}\n  return(output)}\n\nconcat_nodes(nodes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"TH_NP15_GEN-APND,TH_SP15_GEN-APND\"\n```\n:::\n\n```{.r .cell-code}\nnodes<-concat_nodes(nodes)\n```\n:::\n\n\nThe CAISO API requires an ISOFormat for its date input. The function below takes a more common R format and converts it to the necessary ISO format. It should be noted that the minimum query length is one day. If querying part days is necessary then this function could be altered to include a datetime \"hour\".\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncaisodatefmt<-function(x){URLencode(format(lubridate::ymd(as.character(x),tz=\"America/Los_Angeles\"),\"%Y%m%dT07:00-0000\"),reserved = TRUE)}\nisostartdate<-caisodatefmt(startdate)\nisoenddate<-caisodatefmt(enddate)\n```\n:::\n\n\nThis code section will be used to save the zipped file name. This will be important because we will be creating a loop to drop multiple files into our temp folder for extraction.\n\n``` r\nstr(response$headers$`content-disposition`)\ncontent_disposition<-response$headers$`content-disposition`\n filename <- sub(\"^.*filename=\\\"?([^;\\\"]+)\\\"?.*$\", \"\\\\1\", content_disposition)\n```\n\nIf you'd like you can delete the temp folder then all calculations are complete. This part has been removed in the final API because it can only be called once per R session.\n\n``` r\nunlink(temp_dir, recursive = TRUE)\n```\n\nThe script below is a sample that takes a date range and a desired length of days and creates a range between the start and end dates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lubridate)\n\ns <- ymd('2022-01-01')\ne <- ymd('2023-01-01')\nday_chunk<-30\n\nwhile (s <= e) {\n  e_tmp <- s + days(day_chunk)\n  if (e_tmp > e) {\n    e_tmp <- e\n  }\n  print(paste(\"Start Date:\", s, \"End Date:\", e_tmp))\n  s <- e_tmp + days(1)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Start Date: 2022-01-01 End Date: 2022-01-31\"\n[1] \"Start Date: 2022-02-01 End Date: 2022-03-03\"\n[1] \"Start Date: 2022-03-04 End Date: 2022-04-03\"\n[1] \"Start Date: 2022-04-04 End Date: 2022-05-04\"\n[1] \"Start Date: 2022-05-05 End Date: 2022-06-04\"\n[1] \"Start Date: 2022-06-05 End Date: 2022-07-05\"\n[1] \"Start Date: 2022-07-06 End Date: 2022-08-05\"\n[1] \"Start Date: 2022-08-06 End Date: 2022-09-05\"\n[1] \"Start Date: 2022-09-06 End Date: 2022-10-06\"\n[1] \"Start Date: 2022-10-07 End Date: 2022-11-06\"\n[1] \"Start Date: 2022-11-07 End Date: 2022-12-07\"\n[1] \"Start Date: 2022-12-08 End Date: 2023-01-01\"\n```\n:::\n:::\n\n\nThe API call below is where the rubber meets the road. This script is doing three key things.\n\n1.  Its querying the CAISO API and returning a response.\n\n2.  Its saving the returned zipped XML file to a temporary file.\n\n3.  Its unzipping the downloaded XML file and loading it to a dataframe.\n\nIf it seems like a lot, it's because it is...\n\nThis query is looking for an XML file, which is CAISO's preferred format. There is an option for a zipped CSV file. Simply add `resultformat=6` to the params list.\n\nEach query has a different maximum date length you can request. This depends on the granularity of the data being requested. Since we will probably need more than \\~30days of data we will need to implement a loop into our query.\n\n``` r\nstartdate<-'2023-01-01' #Date string in format %Y-%m-%d\nenddate<-'2023-01-31' #Date string in format %Y-%m-%d\nquery<-'DAM' # one of Day Ahead='DAM', 15Min Market='FMM', Real Time='RTM'\nday_chunk<-30 # Default is 30days, but can be adjusted\n```\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(httr)\nlibrary(XML)\nlibrary(xml2)\n\ncaiso_prices<-function(startdate,enddate,query,nodes,day_chunk=30){\n\n  concat_nodes<-function(x){if(length(x)>1){\n   output=paste(x,collapse=\",\") \n  }else{output=x}\n    return(output)}\n  \n  nodes<-concat_nodes(nodes)\n  \n  startdate<-ymd(startdate)\n  enddate<-ymd(enddate)\n  \n  df_output<-data.frame() #Dataframe to store all looped dataframes\n  \n  # If statement to assign API specific variables\n  if(query=='DAM'){\n    queryname<-'PRC_LMP'\n    api_version<-12\n    market_run_id<-'DAM'\n  }else if(query=='RTM'){\n    queryname<-'PRC_INTVL_LMP'\n    api_version<-2\n    market_run_id<-'RTM'\n  }else if(query=='FMM'){\n    queryname<-'PRC_RTPD_LMP'\n    api_version<-3\n    market_run_id<-'RTPD'\n  }else{\n    api_version<-1\n    market_run_id<-'DAM'\n  }\n  \n  # Loop over desired date ranges\n  while (startdate <= enddate) {\n    e_tmp <- startdate + days(day_chunk)\n    if (e_tmp > enddate) {\n      e_tmp <- enddate\n    }\n  # Convert dates to CAISO preferred format\n      caisodatefmt<-function(x){(format(lubridate::ymd(as.character(x),tz=\"America/Los_Angeles\"),\"%Y%m%dT07:00-0000\"))}\n      isostartdate<-caisodatefmt(startdate)\n      isoenddate<-caisodatefmt(e_tmp)\n      \n      endpoint <- 'http://oasis.caiso.com/oasisapi/SingleZip'\n      \n      # Define the parameters for the data you want to retrieve\n      params <- list(\n       # \"resultformat\"=6,\n        \"queryname\" = queryname, # Query Name\n        \"version\" = api_version, # API version\n        \"startdatetime\" = isostartdate,  # Start date and time\n        \"enddatetime\" = isoenddate,    # End date and time\n        \"market_run_id\" = market_run_id,  # Desired Market\n        \"node\" = nodes # Concatenated list of nodes\n      )\n      \n      # Make the API request with parameters\n      full_url<-URLdecode(modify_url(endpoint, query = params)) # This is here to make sure the \":\" render correctly\n      response <- GET(full_url)\n      \n      \n      # Check if the request was successful (status code 200)\n      if (response$status_code == 200) {\n        #Create and store zipped file\n        temp_dir<-tempdir()\n        content_disposition<-response$headers$`content-disposition`\n        filename <- sub(\"^.*filename=\\\"?([^;\\\"]+)\\\"?.*$\", \"\\\\1\", content_disposition)\n        temp_zip_file <- paste0(temp_dir, \"\\\\\", filename)\n       \n        zipped<-writeBin(content(response,as='raw'),temp_zip_file)\n        unzip(temp_zip_file,exdir=temp_dir)\n        extracted_files <- list.files(temp_dir)\n        \n        data_file<-file.path(temp_dir,paste0(tools::file_path_sans_ext(filename),'.xml')) # Specific file pulled. Temp folder may have many.\n        # Parse XML\n        xml_doc <- xmlParse(data_file)\n        root_element <- xmlRoot(xml_doc)\n        \n        # Get the namespace URI\n        namespace_uri <- xmlNamespace(root_element)\n        \n        # Define the namespace prefix and URI\n        namespace_prefix <- \"ns\"\n        namespace_uri <- namespace_uri[[1]]\n        \n        # Find all <REPORT_DATA> elements with the namespace\n        report_data_nodes <- getNodeSet(xml_doc, \"//ns:REPORT_DATA\", namespaces = c(ns = namespace_uri))\n        \n        # Convert the XML data to a data frame\n        df <- xmlToDataFrame(report_data_nodes)\n        \n        df_output<-bind_rows(df_output,df) #combine all results \n        \n      } else {\n        stop(\"API request was not successful.\")\n      }\n    print(paste('Range start:',startdate,' end:',e_tmp))\n    startdate <- e_tmp + days(1) # Increment loop by 1 day\n    Sys.sleep(5) #Sleep so you dont ping the server to death\n    } #end of while loop\n  #unlink(temp_dir, recursive = TRUE) # Currently not used\n  \n  #Convert the GMT or UTC times to the local timezone. \n  df_output<-df_output%>%\n    mutate(\n      START_DATETIME=with_tz(as.POSIXct(INTERVAL_START_GMT, \"%Y-%m-%dT%H:%M:%S\", tz=\"UTC\"),tzone=\"America/Los_Angeles\"),\n           END_DATETIME=with_tz(as.POSIXct(INTERVAL_END_GMT, \"%Y-%m-%dT%H:%M:%S\", tz=\"UTC\"),tzone=\"America/Los_Angeles\"),.after=INTERVAL_END_GMT)\n  return(df_output) # Final output to return\n}#end of function\n```\n:::\n\n\nTake our new function for a spin...\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstartdate<-'2023-01-15'\nenddate<-'2023-01-16'\nquery<-'RTM' \nnodes<-c('TH_NP15_GEN-APND','TH_SP15_GEN-APND')\n\nresult<-caiso_prices(startdate = startdate,enddate=enddate,query = query,nodes = nodes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Range start: 2023-01-15  end: 2023-01-16\"\n```\n:::\n\n```{.r .cell-code}\nresult%>%head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      DATA_ITEM    RESOURCE_NAME   OPR_DATE INTERVAL_NUM\n1  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          277\n2  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          278\n3  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          279\n4  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          280\n5  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          281\n6  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          282\n7  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          283\n8  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          284\n9  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          285\n10 LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          286\n          INTERVAL_START_GMT          INTERVAL_END_GMT      START_DATETIME\n1  2023-01-15T07:00:00-00:00 2023-01-15T07:05:00-00:00 2023-01-14 23:00:00\n2  2023-01-15T07:05:00-00:00 2023-01-15T07:10:00-00:00 2023-01-14 23:05:00\n3  2023-01-15T07:10:00-00:00 2023-01-15T07:15:00-00:00 2023-01-14 23:10:00\n4  2023-01-15T07:15:00-00:00 2023-01-15T07:20:00-00:00 2023-01-14 23:15:00\n5  2023-01-15T07:20:00-00:00 2023-01-15T07:25:00-00:00 2023-01-14 23:20:00\n6  2023-01-15T07:25:00-00:00 2023-01-15T07:30:00-00:00 2023-01-14 23:25:00\n7  2023-01-15T07:30:00-00:00 2023-01-15T07:35:00-00:00 2023-01-14 23:30:00\n8  2023-01-15T07:35:00-00:00 2023-01-15T07:40:00-00:00 2023-01-14 23:35:00\n9  2023-01-15T07:40:00-00:00 2023-01-15T07:45:00-00:00 2023-01-14 23:40:00\n10 2023-01-15T07:45:00-00:00 2023-01-15T07:50:00-00:00 2023-01-14 23:45:00\n          END_DATETIME VALUE\n1  2023-01-14 23:05:00     0\n2  2023-01-14 23:10:00     0\n3  2023-01-14 23:15:00     0\n4  2023-01-14 23:20:00     0\n5  2023-01-14 23:25:00     0\n6  2023-01-14 23:30:00     0\n7  2023-01-14 23:35:00     0\n8  2023-01-14 23:40:00     0\n9  2023-01-14 23:45:00     0\n10 2023-01-14 23:50:00     0\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}