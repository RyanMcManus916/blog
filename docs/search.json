[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "Welcome!\nThis is my blog where I’ll cover topics I find interesting from the electric utility industry. I usually conduct my data science with R or Python, but there will be a sprinkling of other language as necessary to get the job done. Thank you for joining and enjoy the ride!"
  },
  {
    "objectID": "posts/Create Calendar/index.html",
    "href": "posts/Create Calendar/index.html",
    "title": "Create Calendar in R",
    "section": "",
    "text": "On of the most useful things you can create is a function to generate a calendar.\nNecessary packages\n\nCode#install.packages('timeDate')\nlibrary(conflicted)\nlibrary(timeDate)\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n\nCodelibrary(DT)\nconflicted::conflict_prefer_all('tidyverse','stats')\n\n\nIn the electric industry it’s important to be able to summarize data by specific timing blocks. Below a list of North American Electric Reliability Corporation (NERC) holidays.\nSelect the timezone you wish to report in.\n\nCodestartdate&lt;-'2023-01-01'\nenddate&lt;-'2024-02-01'\n#tz_select&lt;-'America/Los_Angeles'\ntz_select&lt;-'UTC'\n\n\nnerc_holidays&lt;-as.Date(timeDate::holidayNERC(lubridate::year(lubridate::ymd(startdate)):lubridate::year(lubridate::ymd(enddate)),FinCenter=tz_select))%&gt;%lubridate::force_tz()\n\n\nCreate the hourly calendar…\nYou can get as creative with the timing periods as you need. Below is the general structure. Please notice the day-of-week (dow) has been changed so the week flows Monday to Sunday or 1 to 7 and hours are represented as Hour-ending.\n\nCodedf&lt;-data.frame(start=lubridate::ymd_h(paste0(startdate,\"_0\"),tz=tz_select),end=lubridate::ymd_h(paste0(enddate,\"_0\")))%&gt;%\n  dplyr::transmute(datetime=list(seq(min(start),max(end),by=\"hour\")))%&gt;%\n  tidyr::unnest(datetime)%&gt;%\n  dplyr::mutate(datetime=lubridate::force_tz(datetime,tz=tz_select))%&gt;%\n  dplyr::mutate(\n    date=lubridate::force_tz(lubridate::as_date(datetime),tz=tz_select),\n    year=lubridate::year(datetime),\n    month=lubridate::month(datetime),\n    day=lubridate::day(datetime),\n    hour=lubridate::hour(datetime)+1,\n    dow=lubridate::wday(datetime,week_start = getOption(\"lubridate.week.start\",1)),\n    nerc_holiday=ifelse(date %in% nerc_holidays,1,0),\n    peak_day=ifelse(dplyr::between(dow,1,6) & nerc_holiday==0,1,0),\n    hlh=ifelse(dplyr::between(dow,1,6) & dplyr::between(hour,7,22) & nerc_holiday==0,1,0),\n    llh=1-hlh,\n    super=ifelse(dplyr::between(dow,1,5) & dplyr::between(hour,13,20) & nerc_holiday==0,1,0),\n    hlh_he13T22=ifelse(dplyr::between(dow,1,6) & dplyr::between(hour,13,22) & nerc_holiday==0,1,0),\n    llh_sun_holiday=ifelse(dow==7 | nerc_holiday==1,1,0)\n  )\n\n\nLet’s take a peak at the results.\n\nCodedf%&gt;%head(50)%&gt;%DT::datatable()\n\n\n\n\n\n\nWe need to double check our results. I refer to Energy GPS Power Calendar. Below is a quick screenshot for reference.\n\n\n\n\nWe need to roll-up our results for comparison.\n\nCodedf%&gt;%\n  dplyr::summarise(dplyr::across(nerc_holiday:llh_sun_holiday,~sum(.)),month_date=max(lubridate::floor_date(date,'month')),.by = c(year,month))%&gt;%\n  mutate(days_in_month=lubridate::days_in_month(month_date),flat=days_in_month*24,peak_day=peak_day/24,nerc_holiday=nerc_holiday/24,.after = peak_day)%&gt;%\n  select(month_date,year,month,flat,hlh,llh,llh_sun_holiday,peak_day,days_in_month,nerc_holiday)%&gt;%\n  DT::datatable()\n\n\n\n\n\n\nLooks good to me!\nBoom. Now you have a NERC calendar you can use in R or drop it to a flat file or a SQL table for different uses. Before we end this, let’s do one more step to make this calendar infinitely more useful. Let’s create a calendar function!\n\nCodecalendar&lt;-function(startdate,enddate,tz_select='UTC',granularity='hour'){\n\n  nerc_holidays&lt;-as.Date(timeDate::holidayNERC(lubridate::year(lubridate::ymd(startdate)):lubridate::year(lubridate::ymd(enddate)),FinCenter=tz_select))%&gt;%lubridate::force_tz()\n  \n  df&lt;-data.frame(start=lubridate::ymd_h(paste0(startdate,\"_0\"),tz=tz_select),end=lubridate::ymd_h(paste0(enddate,\"_0\")))%&gt;%\n  dplyr::transmute(datetime=list(seq(min(start),max(end),by=\"hour\")))%&gt;%\n  tidyr::unnest(datetime)%&gt;%\n  dplyr::mutate(datetime=lubridate::force_tz(datetime,tz=tz_select))%&gt;%\n  dplyr::mutate(\n    date=lubridate::force_tz(lubridate::as_date(datetime),tz=tz_select),\n    year=lubridate::year(datetime),\n    month=lubridate::month(datetime),\n    day=lubridate::day(datetime),\n    hour=lubridate::hour(datetime)+1,\n    dow=lubridate::wday(datetime,week_start = getOption(\"lubridate.week.start\",1)),\n    nerc_holiday=ifelse(date %in% nerc_holidays,1,0),\n    peak_day=ifelse(dplyr::between(dow,1,6) & nerc_holiday==0,1,0),\n    hlh=ifelse(dplyr::between(dow,1,6) & dplyr::between(hour,7,22) & nerc_holiday==0,1,0),\n    llh=1-hlh,\n    super=ifelse(dplyr::between(dow,1,5) & dplyr::between(hour,13,20) & nerc_holiday==0,1,0),\n    hlh_he13T22=ifelse(dplyr::between(dow,1,6) & dplyr::between(hour,13,22) & nerc_holiday==0,1,0),\n    llh_sun_holiday=ifelse(dow==7 | nerc_holiday==1,1,0)\n  )\n  \n  if(granularity=='month'){\n    df&lt;-df%&gt;%dplyr::summarise(dplyr::across(nerc_holiday:llh_sun_holiday,~sum(.)),month_date=max(lubridate::floor_date(date,'month')),.by = c(year,month))%&gt;%\n      mutate(days_in_month=lubridate::days_in_month(month_date),flat=days_in_month*24,peak_day=peak_day/24,nerc_holiday=nerc_holiday/24,.after = peak_day)%&gt;%\n      select(month_date,everything())\n  }\n  \n  return(df)\n  \n}\n\n\nTake the new function for a spin…\n\nCodecalendar('2022-01-01','2023-01-01',granularity = 'month')%&gt;%DT::datatable()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ryan McManus",
    "section": "",
    "text": "I am a Principal Risk Specialist at Sacramento Municipal Utility District (SMUD). I have an extensive background in the electric utility industry, solving data problems in load forecasting, energy trading, long-term portfolio planning, and commodity risk."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blog",
    "section": "",
    "text": "CAISO OASIS API\n\n\n\n\n\n\n\nR\n\n\nfunction\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nNov 1, 2023\n\n\nRyan McManus\n\n\n\n\n\n\n  \n\n\n\n\nCreate Calendar in R\n\n\n\n\n\n\n\nR\n\n\nfunction\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nOct 21, 2023\n\n\nRyan McManus\n\n\n\n\n\n\n  \n\n\n\n\nCreate Calendar in R\n\n\n\n\n\n\n\nR\n\n\nfunction\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nOct 21, 2023\n\n\nRyan McManus\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\n\n\nOct 20, 2023\n\n\nRyan McManus\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/CAISO OASIS API/index.html",
    "href": "posts/CAISO OASIS API/index.html",
    "title": "CAISO OASIS API",
    "section": "",
    "text": "For this post we’ll walk through creating an API function for downloading CAISO OASIS data through their supported API. I will be referencing the Interface Specification for OASIS. This document walks you through how to query the back-end system to extract a variety of data. Today we’ll be looking to get access to their day-ahead, fifteen minute, and real-time markets.\nI will be using the single reports, as described in section 2.1. The basic format goes as followed:\nURL?queryname=&startdate=&enddate=&market_run_id=&varParameters\nUpdated info –https://www.caiso.com/Documents/OASIS-Frequently-Asked-Questions.pdf\nAssemble our variables…\nLet’s setup the initial variables for the query.\n\nCodelibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\nCodelibrary(httr)\nlibrary(XML)\n\nstartdate&lt;-'2023-01-15'\nenddate&lt;-'2023-01-30'\nmarket_run_id&lt;-'RTM'\napi_version&lt;-2\nqueryname&lt;-'PRC_INTVL_LMP'\nnodes&lt;-c('TH_NP15_GEN-APND','TH_SP15_GEN-APND')\n\n\nThis API requires a string of nodes be provided to the call. The function below will concatenate our vector string of nodes.\n\nCodeconcat_nodes&lt;-function(x){if(length(x)&gt;1){\n output=paste(x,collapse=\",\") \n}else{output=x}\n  return(output)}\n\nconcat_nodes(nodes)\n\n[1] \"TH_NP15_GEN-APND,TH_SP15_GEN-APND\"\n\nCodenodes&lt;-concat_nodes(nodes)\n\n\nThe CAISO API requires an ISOFormat for its date input. The function below takes a more common R format and converts it to the necessary ISO format. It should be noted that the minimum query length is one day. If querying part days is necessary then this function could be altered to include a datetime “hour”.\n\nCodecaisodatefmt&lt;-function(x){URLencode(format(lubridate::ymd(as.character(x),tz=\"America/Los_Angeles\"),\"%Y%m%dT07:00-0000\"),reserved = TRUE)}\nisostartdate&lt;-caisodatefmt(startdate)\nisoenddate&lt;-caisodatefmt(enddate)\n\n\nThis code section will be used to save the zipped file name. This will be important because we will be creating a loop to drop multiple files into our temp folder for extraction.\nstr(response$headers$`content-disposition`)\ncontent_disposition&lt;-response$headers$`content-disposition`\n filename &lt;- sub(\"^.*filename=\\\"?([^;\\\"]+)\\\"?.*$\", \"\\\\1\", content_disposition)\nIf you’d like you can delete the temp folder then all calculations are complete. This part has been removed in the final API because it can only be called once per R session.\nunlink(temp_dir, recursive = TRUE)\nThe script below is a sample that takes a date range and a desired length of days and creates a range between the start and end dates.\n\nCodelibrary(lubridate)\n\ns &lt;- ymd('2022-01-01')\ne &lt;- ymd('2023-01-01')\nday_chunk&lt;-30\n\nwhile (s &lt;= e) {\n  e_tmp &lt;- s + days(day_chunk)\n  if (e_tmp &gt; e) {\n    e_tmp &lt;- e\n  }\n  print(paste(\"Start Date:\", s, \"End Date:\", e_tmp))\n  s &lt;- e_tmp + days(1)\n}\n\n[1] \"Start Date: 2022-01-01 End Date: 2022-01-31\"\n[1] \"Start Date: 2022-02-01 End Date: 2022-03-03\"\n[1] \"Start Date: 2022-03-04 End Date: 2022-04-03\"\n[1] \"Start Date: 2022-04-04 End Date: 2022-05-04\"\n[1] \"Start Date: 2022-05-05 End Date: 2022-06-04\"\n[1] \"Start Date: 2022-06-05 End Date: 2022-07-05\"\n[1] \"Start Date: 2022-07-06 End Date: 2022-08-05\"\n[1] \"Start Date: 2022-08-06 End Date: 2022-09-05\"\n[1] \"Start Date: 2022-09-06 End Date: 2022-10-06\"\n[1] \"Start Date: 2022-10-07 End Date: 2022-11-06\"\n[1] \"Start Date: 2022-11-07 End Date: 2022-12-07\"\n[1] \"Start Date: 2022-12-08 End Date: 2023-01-01\"\n\n\nThe API call below is where the rubber meets the road. This script is doing three key things.\n\nIts querying the CAISO API and returning a response.\nIts saving the returned zipped XML file to a temporary file.\nIts unzipping the downloaded XML file and loading it to a dataframe.\n\nIf it seems like a lot, it’s because it is…\nThis query is looking for an XML file, which is CAISO’s preferred format. There is an option for a zipped CSV file. Simply add resultformat=6 to the params list.\nEach query has a different maximum date length you can request. This depends on the granularity of the data being requested. Since we will probably need more than ~30days of data we will need to implement a loop into our query.\nstartdate&lt;-'2023-01-01' #Date string in format %Y-%m-%d\nenddate&lt;-'2023-01-31' #Date string in format %Y-%m-%d\nquery&lt;-'DAM' # one of Day Ahead='DAM', 15Min Market='FMM', Real Time='RTM'\nday_chunk&lt;-30 # Default is 30days, but can be adjusted\n\nCodelibrary(tidyverse)\nlibrary(httr)\nlibrary(XML)\nlibrary(xml2)\n\ncaiso_prices&lt;-function(startdate,enddate,query,nodes,day_chunk=30){\n\n  concat_nodes&lt;-function(x){if(length(x)&gt;1){\n   output=paste(x,collapse=\",\") \n  }else{output=x}\n    return(output)}\n  \n  nodes&lt;-concat_nodes(nodes)\n  \n  startdate&lt;-ymd(startdate)\n  enddate&lt;-ymd(enddate)\n  \n  df_output&lt;-data.frame() #Dataframe to store all looped dataframes\n  \n  # If statement to assign API specific variables\n  if(query=='DAM'){\n    queryname&lt;-'PRC_LMP'\n    api_version&lt;-12\n    market_run_id&lt;-'DAM'\n  }else if(query=='RTM'){\n    queryname&lt;-'PRC_INTVL_LMP'\n    api_version&lt;-2\n    market_run_id&lt;-'RTM'\n  }else if(query=='FMM'){\n    queryname&lt;-'PRC_RTPD_LMP'\n    api_version&lt;-3\n    market_run_id&lt;-'RTPD'\n  }else{\n    api_version&lt;-1\n    market_run_id&lt;-'DAM'\n  }\n  \n  # Loop over desired date ranges\n  while (startdate &lt;= enddate) {\n    e_tmp &lt;- startdate + days(day_chunk)\n    if (e_tmp &gt; enddate) {\n      e_tmp &lt;- enddate\n    }\n  # Convert dates to CAISO preferred format\n      caisodatefmt&lt;-function(x){(format(lubridate::ymd(as.character(x),tz=\"America/Los_Angeles\"),\"%Y%m%dT07:00-0000\"))}\n      isostartdate&lt;-caisodatefmt(startdate)\n      isoenddate&lt;-caisodatefmt(e_tmp)\n      \n      endpoint &lt;- 'http://oasis.caiso.com/oasisapi/SingleZip'\n      \n      # Define the parameters for the data you want to retrieve\n      params &lt;- list(\n       # \"resultformat\"=6,\n        \"queryname\" = queryname, # Query Name\n        \"version\" = api_version, # API version\n        \"startdatetime\" = isostartdate,  # Start date and time\n        \"enddatetime\" = isoenddate,    # End date and time\n        \"market_run_id\" = market_run_id,  # Desired Market\n        \"node\" = nodes # Concatenated list of nodes\n      )\n      \n      # Make the API request with parameters\n      full_url&lt;-URLdecode(modify_url(endpoint, query = params)) # This is here to make sure the \":\" render correctly\n      response &lt;- GET(full_url)\n      \n      \n      # Check if the request was successful (status code 200)\n      if (response$status_code == 200) {\n        #Create and store zipped file\n        temp_dir&lt;-tempdir()\n        content_disposition&lt;-response$headers$`content-disposition`\n        filename &lt;- sub(\"^.*filename=\\\"?([^;\\\"]+)\\\"?.*$\", \"\\\\1\", content_disposition)\n        temp_zip_file &lt;- paste0(temp_dir, \"\\\\\", filename)\n       \n        zipped&lt;-writeBin(content(response,as='raw'),temp_zip_file)\n        unzip(temp_zip_file,exdir=temp_dir)\n        extracted_files &lt;- list.files(temp_dir)\n        \n        data_file&lt;-file.path(temp_dir,paste0(tools::file_path_sans_ext(filename),'.xml')) # Specific file pulled. Temp folder may have many.\n        # Parse XML\n        xml_doc &lt;- xmlParse(data_file)\n        root_element &lt;- xmlRoot(xml_doc)\n        \n        # Get the namespace URI\n        namespace_uri &lt;- xmlNamespace(root_element)\n        \n        # Define the namespace prefix and URI\n        namespace_prefix &lt;- \"ns\"\n        namespace_uri &lt;- namespace_uri[[1]]\n        \n        # Find all &lt;REPORT_DATA&gt; elements with the namespace\n        report_data_nodes &lt;- getNodeSet(xml_doc, \"//ns:REPORT_DATA\", namespaces = c(ns = namespace_uri))\n        \n        # Convert the XML data to a data frame\n        df &lt;- xmlToDataFrame(report_data_nodes)\n        \n        df_output&lt;-bind_rows(df_output,df) #combine all results \n        \n      } else {\n        stop(\"API request was not successful.\")\n      }\n    print(paste('Range start:',startdate,' end:',e_tmp))\n    startdate &lt;- e_tmp + days(1) # Increment loop by 1 day\n    Sys.sleep(5) #Sleep so you dont ping the server to death\n    } #end of while loop\n  #unlink(temp_dir, recursive = TRUE) # Currently not used\n  \n  #Convert the GMT or UTC times to the local timezone. \n  df_output&lt;-df_output%&gt;%\n    mutate(\n      START_DATETIME=with_tz(as.POSIXct(INTERVAL_START_GMT, \"%Y-%m-%dT%H:%M:%S\", tz=\"UTC\"),tzone=\"America/Los_Angeles\"),\n           END_DATETIME=with_tz(as.POSIXct(INTERVAL_END_GMT, \"%Y-%m-%dT%H:%M:%S\", tz=\"UTC\"),tzone=\"America/Los_Angeles\"),.after=INTERVAL_END_GMT)\n  return(df_output) # Final output to return\n}#end of function\n\n\nTake our new function for a spin…\n\nCodestartdate&lt;-'2023-01-15'\nenddate&lt;-'2023-01-16'\nquery&lt;-'RTM' \nnodes&lt;-c('TH_NP15_GEN-APND','TH_SP15_GEN-APND')\n\nresult&lt;-caiso_prices(startdate = startdate,enddate=enddate,query = query,nodes = nodes)\n\n[1] \"Range start: 2023-01-15  end: 2023-01-16\"\n\nCoderesult%&gt;%head(10)\n\n      DATA_ITEM    RESOURCE_NAME   OPR_DATE INTERVAL_NUM\n1  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          277\n2  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          278\n3  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          279\n4  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          280\n5  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          281\n6  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          282\n7  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          283\n8  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          284\n9  LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          285\n10 LMP_CONG_PRC TH_NP15_GEN-APND 2023-01-14          286\n          INTERVAL_START_GMT          INTERVAL_END_GMT      START_DATETIME\n1  2023-01-15T07:00:00-00:00 2023-01-15T07:05:00-00:00 2023-01-14 23:00:00\n2  2023-01-15T07:05:00-00:00 2023-01-15T07:10:00-00:00 2023-01-14 23:05:00\n3  2023-01-15T07:10:00-00:00 2023-01-15T07:15:00-00:00 2023-01-14 23:10:00\n4  2023-01-15T07:15:00-00:00 2023-01-15T07:20:00-00:00 2023-01-14 23:15:00\n5  2023-01-15T07:20:00-00:00 2023-01-15T07:25:00-00:00 2023-01-14 23:20:00\n6  2023-01-15T07:25:00-00:00 2023-01-15T07:30:00-00:00 2023-01-14 23:25:00\n7  2023-01-15T07:30:00-00:00 2023-01-15T07:35:00-00:00 2023-01-14 23:30:00\n8  2023-01-15T07:35:00-00:00 2023-01-15T07:40:00-00:00 2023-01-14 23:35:00\n9  2023-01-15T07:40:00-00:00 2023-01-15T07:45:00-00:00 2023-01-14 23:40:00\n10 2023-01-15T07:45:00-00:00 2023-01-15T07:50:00-00:00 2023-01-14 23:45:00\n          END_DATETIME VALUE\n1  2023-01-14 23:05:00     0\n2  2023-01-14 23:10:00     0\n3  2023-01-14 23:15:00     0\n4  2023-01-14 23:20:00     0\n5  2023-01-14 23:25:00     0\n6  2023-01-14 23:30:00     0\n7  2023-01-14 23:35:00     0\n8  2023-01-14 23:40:00     0\n9  2023-01-14 23:45:00     0\n10 2023-01-14 23:50:00     0"
  },
  {
    "objectID": "posts/TidyTuesday 2024 Week 41/index.html",
    "href": "posts/TidyTuesday 2024 Week 41/index.html",
    "title": "Create Calendar in R",
    "section": "",
    "text": "One of the most useful things you can create is a function to generate a calendar.\nNecessary packages\n\nCode#install.packages('timeDate')\nlibrary(conflicted)\nlibrary(timeDate)\n\nWarning: package 'timeDate' was built under R version 4.3.2\n\nCodelibrary(tidyverse)\n\nWarning: package 'tidyverse' was built under R version 4.3.3\n\n\nWarning: package 'dplyr' was built under R version 4.3.2\n\n\nWarning: package 'stringr' was built under R version 4.3.2\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n\nCodelibrary(DT)\n\nWarning: package 'DT' was built under R version 4.3.2\n\nCodeconflicted::conflict_prefer_all('tidyverse','stats')\n\n\nIn the electric industry it’s important to be able to summarize data by specific timing blocks. Below is a list of North American Electric Reliability Corporation (NERC) holidays.\nSelect the timezone you wish to report in.\n\nCodestartdate&lt;-'2023-01-01'\nenddate&lt;-'2024-02-01'\n#tz_select&lt;-'America/Los_Angeles'\ntz_select&lt;-'UTC'\n\n\nnerc_holidays&lt;-as.Date(timeDate::holidayNERC(lubridate::year(lubridate::ymd(startdate)):lubridate::year(lubridate::ymd(enddate)),FinCenter=tz_select))%&gt;%lubridate::force_tz()\n\n\nCreate the hourly calendar…\nYou can get as creative with the timing periods as you need. Below is the general structure. Please notice the day-of-week (dow) has been changed so the week flows Monday to Sunday or 1 to 7 and hours are represented as hour-ending.\n\nCodedf&lt;-data.frame(start=lubridate::ymd_h(paste0(startdate,\"_0\"),tz=tz_select),end=lubridate::ymd_h(paste0(enddate,\"_0\")))%&gt;%\n  dplyr::transmute(datetime=list(seq(min(start),max(end),by=\"hour\")))%&gt;%\n  tidyr::unnest(datetime)%&gt;%\n  dplyr::mutate(datetime=lubridate::force_tz(datetime,tz=tz_select))%&gt;%\n  dplyr::mutate(\n    date=lubridate::force_tz(lubridate::as_date(datetime),tz=tz_select),\n    year=lubridate::year(datetime),\n    month=lubridate::month(datetime),\n    day=lubridate::day(datetime),\n    hour=lubridate::hour(datetime)+1,\n    dow=lubridate::wday(datetime,week_start = getOption(\"lubridate.week.start\",1)),\n    nerc_holiday=ifelse(date %in% nerc_holidays,1,0),\n    peak_day=ifelse(dplyr::between(dow,1,6) & nerc_holiday==0,1,0),\n    hlh=ifelse(dplyr::between(dow,1,6) & dplyr::between(hour,7,22) & nerc_holiday==0,1,0),\n    llh=1-hlh,\n    super=ifelse(dplyr::between(dow,1,5) & dplyr::between(hour,13,20) & nerc_holiday==0,1,0),\n    hlh_he13T22=ifelse(dplyr::between(dow,1,6) & dplyr::between(hour,13,22) & nerc_holiday==0,1,0),\n    llh_sun_holiday=ifelse(dow==7 | nerc_holiday==1,1,0)\n  )\n\n\nLet’s take a peak at the results.\n\nCodedf%&gt;%head(50)%&gt;%DT::datatable()\n\n\n\n\n\n\nWe need to double check our results. I refer to Energy GPS Power Calendar. Below is a quick screenshot for reference.\n\n\n\n\nWe need to roll-up our results for comparison.\n\nCodedf%&gt;%\n  dplyr::summarise(dplyr::across(nerc_holiday:llh_sun_holiday,~sum(.)),month_date=max(lubridate::floor_date(date,'month')),.by = c(year,month))%&gt;%\n  mutate(days_in_month=lubridate::days_in_month(month_date),flat=days_in_month*24,peak_day=peak_day/24,nerc_holiday=nerc_holiday/24,.after = peak_day)%&gt;%\n  select(month_date,year,month,flat,hlh,llh,llh_sun_holiday,peak_day,days_in_month,nerc_holiday)%&gt;%\n  DT::datatable()\n\n\n\n\n\n\nLooks good to me!\nBoom. Now you have a NERC calendar you can use in R or drop it to a flat file or a SQL table for different uses. Before we end this, let’s do one more step to make this calendar infinitely more useful. Let’s create a calendar function!\n\nCodecalendar&lt;-function(startdate,enddate,tz_select='UTC',granularity='hour'){\n\n  nerc_holidays&lt;-as.Date(timeDate::holidayNERC(lubridate::year(lubridate::ymd(startdate)):lubridate::year(lubridate::ymd(enddate)),FinCenter=tz_select))%&gt;%lubridate::force_tz()\n  \n  df&lt;-data.frame(start=lubridate::ymd_h(paste0(startdate,\"_0\"),tz=tz_select),end=lubridate::ymd_h(paste0(enddate,\"_0\")))%&gt;%\n  dplyr::transmute(datetime=list(seq(min(start),max(end),by=\"hour\")))%&gt;%\n  tidyr::unnest(datetime)%&gt;%\n  dplyr::mutate(datetime=lubridate::force_tz(datetime,tz=tz_select))%&gt;%\n  dplyr::mutate(\n    date=lubridate::force_tz(lubridate::as_date(datetime),tz=tz_select),\n    year=lubridate::year(datetime),\n    month=lubridate::month(datetime),\n    day=lubridate::day(datetime),\n    hour=lubridate::hour(datetime)+1,\n    dow=lubridate::wday(datetime,week_start = getOption(\"lubridate.week.start\",1)),\n    nerc_holiday=ifelse(date %in% nerc_holidays,1,0),\n    peak_day=ifelse(dplyr::between(dow,1,6) & nerc_holiday==0,1,0),\n    hlh=ifelse(dplyr::between(dow,1,6) & dplyr::between(hour,7,22) & nerc_holiday==0,1,0),\n    llh=1-hlh,\n    super=ifelse(dplyr::between(dow,1,5) & dplyr::between(hour,13,20) & nerc_holiday==0,1,0),\n    hlh_he13T22=ifelse(dplyr::between(dow,1,6) & dplyr::between(hour,13,22) & nerc_holiday==0,1,0),\n    llh_sun_holiday=ifelse(dow==7 | nerc_holiday==1,1,0)\n  )\n  \n  if(granularity=='month'){\n    df&lt;-df%&gt;%dplyr::summarise(dplyr::across(nerc_holiday:llh_sun_holiday,~sum(.)),month_date=max(lubridate::floor_date(date,'month')),.by = c(year,month))%&gt;%\n      mutate(days_in_month=lubridate::days_in_month(month_date),flat=days_in_month*24,peak_day=peak_day/24,nerc_holiday=nerc_holiday/24,.after = peak_day)%&gt;%\n      select(month_date,everything())\n  }\n  \n  return(df)\n  \n}\n\n\nTake the new function for a spin…\n\nCodecalendar('2022-01-01','2023-01-01',granularity = 'month')%&gt;%DT::datatable()"
  }
]